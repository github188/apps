#!/usr/bin/env python
# -*- coding: utf-8 -*-

# -----------------------------------------------------------------------------
# 文件名称: handle_disk
# 作用: 处理磁盘上下线事件
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# 输入参数格式:
#     argv[0] - (this program)
#     argv[1] - disk dev (eg. /dev/sdb)
#     argv[2] - action <add|remove|change>
# -----------------------------------------------------------------------------

import sys,os
import time
from libmd import *
from libdisk import *

reload(sys)
sys.setdefaultencoding('utf8')


# -------- 磁盘信息定义 -----------
class DiskInfo():
	def __init__(self):
		self.dev = ''		# eg. /dev/sdb
		self.slot = ''
		self.uuid = ''
		self.md_uuid = ''

def get_disk_info(disk_dev):
	info = DiskInfo()
	info.dev = disk_dev
	info.slot = disk_slot(disk_dev)
	ret,txt = commands.getstatusoutput('mdadm -E %s' % disk_dev)
	if ret == 0:
		for line in txt.split('\n'):
			if line.find('Device UUID : ') >= 0:
				info.uuid = line.split('Device UUID : ')[-1]
			elif line.find('Array UUID : ') >= 0:
				info.md_uuid = line.split('Array UUID : ')[-1]
	return info


# -------------------------------------------------------------------------
#    实用函数
# -------------------------------------------------------------------------

# 记录日志
def __md_event_log(event, content):
	LogInsert('VG', 'Auto', event, content)

# 蜂鸣器告警
def __buzzer_alarm():
	os.popen('set-buzzer.sh on')

# 从指定卷组删除掉盘的磁盘
def __remove_disk_from_md(mddev, diskdev):
	cmd = 'mdadm --set-faulty %s %s 2>&1' % (mddev, diskdev)
	ret,msg = commands.getstatusoutput(cmd)
	
	cmd = 'mdadm --remove %s %s 2>&1' % (mddev, diskdev)
	ret,msg = commands.getstatusoutput(cmd)
	return ret

# 将磁盘加入指定卷组
def __add_disk_to_md(mddev, diskdev):
	cmd = 'mdadm --add %s %s 2>&1' % (mddev, diskdev)
	ret,msg = commands.getstatusoutput(cmd)
	return ret

# 使用磁盘dev节点名称查找所在的卷组信息
def __find_md_by_disk_dev(disk_dev):
	mdinfo = None
	try:
		f = open('/proc/mdstat', 'r')
		for x in f.readlines():
			mddev = re.match('^md\d*', x)
			if mddev is None:
				continue
			if dev_trim(disk_dev) in re.findall('sd\w+', x):
				mdinfo = mddev_get_attr('/dev/%s' % mddev.group())
				break
		f.close()
	except:
		pass
	return mdinfo

# 使用磁盘uuid查找所在卷组信息
def __find_md_by_disk_mduuid(disk_mduuid):
	for mdinfo in md_info()['rows']:
		if disk_mduuid == mdinfo['raid_uuid']:
			return mdinfo
	return None


# 磁盘上线事件处理
def __handle_disk_add(diskinfo):
	mdinfo = __find_md_by_disk_mduuid(diskinfo.md_uuid)
	if mdinfo == None:
		return

	if mdinfo['raid_state'] != 'degrade':
		return
	
	if __add_disk_to_md(mdinfo['dev'], diskinfo.dev) == 0:
		__md_event_log('Warning', '卷组 %s 所属磁盘 %s 重新加入卷组操作成功' % (mdinfo['name'], diskinfo.slot))
		disk_slot_update(diskinfo.slot)
	else:
		__md_event_log('Error', '卷组 %s 所属磁盘 %s 重新加入卷组操作失败' % (mdinfo['name'], diskinfo.slot))

# 磁盘掉线和被踢事件处理
def __handle_disk_remove_kicked(diskinfo, event):
	mdinfo = __find_md_by_disk_dev(diskinfo.dev)
	if mdinfo == None:
		return

	if __remove_disk_from_md(mdinfo['dev'], diskinfo.dev) != 0:
		__md_event_log('Warning', '从卷组 %s 删除磁盘 %s 失败' % (mdinfo['name'], diskinfo.slot))
	# 更新被踢掉的磁盘状态
	if diskinfo.slot != '':
		disk_slot_update(diskinfo.slot)

	mdinfo = mddev_get_attr(mdinfo['dev'])	# 因为删除磁盘, 重新获取状态
	_state = mdinfo['raid_state']
	if _state == 'degrade':
		msg = '卷组 %s 降级' % mdinfo['name']
		__md_event_log('Warning', msg)
		sysmon_event('vg', 'degrade', 'disks=%s' % disk_list_str(mdinfo['disk_list']), msg)
		
		# 掉盘后等待5分钟, 如果磁盘重新上线可快速重建RAID, 不需要使用热备盘重建
		# 等待后重新获取状态, 如果不再是degrade状态, 则不需要处理
		if event == 'remove':
			time.sleep(300)
			mdinfo = mddev_get_attr(mdinfo['dev'])
			if mdinfo['raid_state'] != 'degrade':
				return				

		__handle_md_rebuild(mdinfo)
		
	elif _state == 'fail':
		msg = '卷组 %s 失效' % mdinfo['name']
		__md_event_log('Error', msg)
		sysmon_event('vg', 'degrade', 'disks=%s' % disk_list_str(mdinfo['disk_list']), msg)
		__buzzer_alarm()

	else:
		__md_event_log('Error', '卷组 %s 状态出错, 当前状态 %s' % (mdinfo['name'], _state))
		__buzzer_alarm()

	return

def __handle_md_rebuild(mdinfo):
	# 使用文件锁同步多个raid重建, 防止争抢全局热备盘和空闲盘
	f_lock = lock_file('/tmp/.raid_rebuild_lock')
	if None == f_lock:
		__md_event_log('Error', '系统异常: 打开文件/tmp/.raid_rebuild_lock失败')
		return

	disk = md_get_hotrep(mdinfo['raid_uuid'])
	if disk == {}:
		disk = get_free_disk()
	if disk == {}:
		__md_event_log('Error', '未找到热备盘和空闲盘重建卷组 %s' % mdinfo['name'])
		#__buzzer_alarm()
		unlock_file(f_lock)
		return

	slot = disk_serial2slot(disk['serial'])
	name = disk_name(slot)
	if __add_disk_to_md(mdinfo['dev'], name) == 0:
		__md_event_log('Info', '使用 %s %s 重建卷组 %s 成功' % (slot, disk['type']), mdinfo['name'])
		disk_clean_hotrep(slot)
		disk_slot_update(slot)

	else:
		__md_event_log('Error', '使用 %s %s 重建卷组 %s 失败' % (slot, disk['type']), mdinfo['name'])
	unlock_file(f_lock)

# 主函数
def main():

	# 参数检查
	if len(sys.argv) < 2:
		# 记录日志, 返回
		return

	diskinfo = get_disk_info(sys.argv[1])  # argv[1] - disk_dev
	event = sys.argv[2]
	if event == 'add':
		msg = '磁盘 %s 上线' % diskinfo.slot if diskinfo.slot != '' else '磁盘上线'
		__md_event_log('Info', msg)
		sysmon_event('disk', 'online', 'disk=%s' % diskinfo.slot, msg)
		__handle_disk_add(diskinfo)

	elif event == 'remove':
		msg = '磁盘 %s 掉线' % diskinfo.slot if diskinfo.slot != '' else '磁盘掉线'
		__md_event_log('Info', msg)
		sysmon_event('disk', 'offline', 'disk=%s' % diskinfo.slot, msg)
		__handle_disk_remove_kicked(diskinfo, 'remove')

	elif event == 'kicked':
		msg = '磁盘 %s 故障' % diskinfo.slot if diskinfo.slot != '' else '磁盘故障'
		__md_event_log('Info', msg)
		sysmon_event('disk', 'fail', 'disk=%s' % diskinfo.slot, msg)
		__handle_disk_remove_kicked(diskinfo, 'kicked')

if __name__ == "__main__":
	main()
